package com.example.repository;

import static com.example.database.generatedclasses.Tables.AUTHOR;
import static com.example.database.generatedclasses.Tables.BOOK;

import java.util.List;

import org.jooq.DSLContext;
import org.jooq.Record;
import org.jooq.Result;
import org.springframework.stereotype.Repository;

import com.example.database.generatedclasses.tables.daos.AuthorDao;
import com.example.database.generatedclasses.tables.pojos.Author;
import com.example.database.generatedclasses.tables.pojos.Book;
import com.example.database.generatedclasses.tables.records.AuthorRecord;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Repository
@RequiredArgsConstructor
@Slf4j
public class AuthorRepository extends AuthorDao {

    private final DSLContext create;

    public List<Author> getByName(String firstName, String lastName){
        return create.select().from(AUTHOR)
            .where(AUTHOR.FIRST_NAME.eq(firstName))
            .and(AUTHOR.LAST_NAME.eq(lastName))
            .fetch().into(Author.class);
    }
    public List<Author> getAuthors(){
        return create.select().from(AUTHOR).fetch().into(Author.class);
    }
    public List<String> getFirstNames() {
        return this.create.selectFrom(AUTHOR).fetch(AUTHOR.FIRST_NAME);
    }
    // Insert using record and map into a POJO generated by JOOQ
    public com.example.database.generatedclasses.tables.pojos.Author insert(String firstName, String lastName){
        AuthorRecord author = create.newRecord(AUTHOR);
        author.setFirstName(firstName);
        author.setLastName(lastName);
        author.store();
        com.example.database.generatedclasses.tables.pojos.Author result = author.into(com.example.database.generatedclasses.tables.pojos.Author.class);
        log.info("Inserted author via create.newRecord and mapping into Author POJO, result is: " + author.toString());
        return result;
    }
    // Given an author, show me the authors information plus all of their books
    // I wonder how SQL injection is prevented here...
    public void selectIntoMultipleObjects(String firstName, String lastName){
        // Get the authorId from the name
        // Will Java autocast Integer -> int? I think auto-unboxing is fine, as we're losing information, can we go the other way? int -> Integer?
        int authorId = create.select(AUTHOR.ID).from(AUTHOR)
        .where(AUTHOR.FIRST_NAME.eq(firstName))
        .and(AUTHOR.LAST_NAME.eq(lastName))
        .fetchOne().into(Integer.class);
        Result<Record> record = create.select(
        ).from(AUTHOR)
            .join(BOOK).on(AUTHOR.ID.eq(BOOK.AUTHOR_ID))
            .where(AUTHOR.ID.eq(authorId))
            .fetch();
        // Haven't used this code.. but if you wanted the specific record types VS the POJOs
        //Result<AuthorRecord> authorRecord = record.into(AUTHOR);
        //Result<BookRecord> bookRecord = record.into(BOOK);
        List<com.example.database.generatedclasses.tables.pojos.Author> authors = record.into(AUTHOR).into(Author.class);
        List<Book> books = record.into(BOOK).into(Book.class);
        log.info("Showing all books for the given author: " + firstName + " " + lastName);
        authors.stream().forEach(a -> log.info(a.toString()));
        books.stream().forEach(b -> log.info(b.toString()));
    }
}