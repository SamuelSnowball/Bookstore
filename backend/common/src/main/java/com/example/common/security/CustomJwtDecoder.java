package com.example.common.security;

import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

/**
 * Custom JWT decoder that bridges the gap between jjwt library (io.jsonwebtoken) 
 * and Spring Security's OAuth2 Resource Server.
 * 
 * <p>This decoder is necessary because tokens generated by the jjwt library using 
 * {@code Jwts.builder().signWith(key)} are incompatible with Spring's NimbusJwtDecoder,
 * even when using matching secret keys and HS256 algorithm. NimbusJwtDecoder expects
 * tokens formatted according to Nimbus JOSE JWT library specifications, which differ
 * subtly from jjwt's token structure.</p>
 * 
 * <p>This custom implementation wraps our existing {@link JwtUtil} (which uses jjwt)
 * to validate and extract claims from tokens, then converts the result into Spring
 * Security's {@link Jwt} format for OAuth2 Resource Server integration.</p>
 */
@Component
public class CustomJwtDecoder implements JwtDecoder {
    
    private final JwtUtil jwtUtil;
    
    public CustomJwtDecoder(JwtUtil jwtUtil) {
        this.jwtUtil = jwtUtil;
    }
    
    /**
     * Decodes and validates a JWT token string into Spring Security's Jwt object.
     * 
     * <p>This method uses {@link JwtUtil} (jjwt-based) to perform the actual token
     * validation and claim extraction, then wraps the result in Spring Security's
     * {@link Jwt} format for compatibility with OAuth2 Resource Server.</p>
     *
     * @param token the JWT token string (without "Bearer " prefix)
     * @return a validated Spring Security {@link Jwt} object containing claims
     * @throws JwtException if the token is invalid, expired, or malformed
     */
    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            // Use our existing JwtUtil to extract claims
            String username = jwtUtil.extractUsername(token);
            Integer userId = jwtUtil.extractUserId(token);
            
            // Validate token
            if (!jwtUtil.validateToken(token, username)) {
                throw new JwtException("Invalid JWT token");
            }
            
            // Build claims map
            Map<String, Object> claims = new HashMap<>();
            claims.put("sub", username);
            claims.put("userId", userId);
            
            // Build headers
            Map<String, Object> headers = new HashMap<>();
            headers.put("alg", "HS256");
            headers.put("typ", "JWT");
            
            // Create Spring Security JWT
            Instant issuedAt = Instant.now();
            Instant expiresAt = jwtUtil.extractExpiration(token).toInstant();
            
            return new Jwt(token, issuedAt, expiresAt, headers, claims);
            
        } catch (Exception e) {
            throw new JwtException("Failed to decode JWT", e);
        }
    }
}
